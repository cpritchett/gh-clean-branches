#!/bin/zsh

# safely delete local branches that have no remotes and no hanging changes
# will not delete branches with not committed changes
# run inside a git repo folder

DRY_RUN=false

while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --dry-run )
      DRY_RUN=true
      shift
      ;;
    --force)
      FORCE_DELETE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    * )
      printf "%s\n" "Usage: gh clean-branches [--dry-run] [--force] [--verbose]"
      exit 1
      ;;
  esac
done

red=$(printf '\e[1;31m')
green=$(printf '\e[1;32m')
yellow=$(printf '\e[1;33m')
blue=$(printf '\e[1;34m')
end=$(printf '\e[0m')

# Function to check if a branch was effectively merged via squash/rebase
# Returns 0 if the branch is safe to delete, 1 otherwise
is_branch_safely_merged() {
    local branch="$1"
    local default_branch="$2"
    
    # Get the merge base between the branch and default branch
    local merge_base=$(git merge-base "$branch" "$default_branch" 2>/dev/null)
    
    # If no merge base, not safe to delete
    if [[ -z "$merge_base" ]]; then
        return 1
    fi
    
    # Check if there are any commits in the branch that aren't in the default branch
    local unique_commits=$(git rev-list "$default_branch..$branch" 2>/dev/null | wc -l)
    
    # If there are no unique commits, the branch was merged
    if [[ "$unique_commits" -eq 0 ]]; then
        return 0
    fi
    
    # For squash/rebase merges, check if all changes from the branch are already in default branch
    # Get the diff between the merge base and the branch
    local branch_diff=$(git diff "$merge_base..$branch" 2>/dev/null)
    
    # If the branch has no changes compared to merge base, it's safe
    if [[ -z "$branch_diff" ]]; then
        return 0
    fi
    
    # Check if the same changes exist in the default branch since the merge base
    local default_diff=$(git diff "$merge_base..$default_branch" 2>/dev/null)
    
    # If the branch changes are contained within the default branch changes, it's safe
    # This handles most squash merge scenarios where the exact same diff was applied
    if [[ -n "$default_diff" ]] && echo "$default_diff" | grep -qF "$branch_diff" 2>/dev/null; then
        return 0
    fi
    
    return 1
}

printf "%s\n" "${green}Sync branches${end}"
git fetch -p >/dev/null 2>&1 # hide response

upstream_name=$(git remote show)
home_branch=$(git branch --show-current)

# Pull all upstream
for upstream_name in $(git remote show); do
  default_branch=$(LANG=en_GB git remote show ${upstream_name} | awk '/HEAD branch/ {print $NF}')

  printf "%s\n" "${green}Checking out ${upstream_name}/${default_branch}${end}"
  git checkout $default_branch -q

  printf "%s\n" "${green}Pulling ${upstream_name}/${default_branch}${end}"
  git pull ${upstream_name} ${default_branch} -q
  if [[ $? -ne 0 ]]; then
      printf "%s\n" "${red}Failed to pull, check for uncommitted changes.${end}"
      exit 1
  fi

  # get al upstream branches (e.g. origin/my-branch)
  upstream_branches_str=$(git for-each-ref --format='%(refname:short)' refs/remotes/${upstream_name})
  # trim the upstream name (e.g. "origin/") from branch names
  upstream_branches_str=${upstream_branches_str//${upstream_name}\// }
  # accumulated branches from all upstream
  remote_branches_str="${remote_branches_str}${upstream_branches_str}\n"

  if [[ ${VERBOSE} == true ]]; then
    printf "%s\n%s\n" "${blue}Remote branches on ${upstream_name}:${end}" "${upstream_branches_str}"
  fi
done

unique_remote_branches_str=$(echo "${remote_branches_str}" | sort -u)

local_branches_str=$(git branch)
local_branches_str=${local_branches_str/\*?/  }                # trim the "*"" on the current branch
local_branches_str=${local_branches_str/\ ?refs\/heads?/}      # remove the "refs/heads" if exists

if [[ ${VERBOSE} == true ]]; then
  printf "%s\n%s\n" "${blue}Local branches:${end}" "${local_branches_str}"
fi

setopt extended_glob
local_branches=("${(f)local_branches_str}")                    # split string by \n to array
local_branches=(${local_branches:#* ${default_branch}})        # filter out default_branch
local_branches=(${local_branches// ##})                        # trim spaces

remote_branches=("${(f)unique_remote_branches_str}")           # split string by \n to array
remote_branches=(${remote_branches:#* ${default_branch}})      # filter out default_branch
remote_branches=(${remote_branches// ##})                      # trim spaces

missing_upstream_branches=(${local_branches:|remote_branches}) # local_branches minus remote_branches

branches_count=${#missing_upstream_branches[@]}

if [[ ${FORCE_DELETE} == true ]]; then
  delete_flag='-D'
else
  delete_flag='-d'
fi

if [[ ${branches_count} -eq 0 ]]; then
    printf "%s\n" "${green}No local branches with missing upstream found${end}"
else
    printf "%s\n" "${blue}Local branches with missing upstream:${end}"
    for branch in "${missing_upstream_branches[@]}"; do
        printf "%s\n" "   ${branch}"
    done

    if [[ ${DRY_RUN} == false ]]; then
      [[ ${FORCE_DELETE} == true ]] && printf "%s\n" "${yellow}Force delete is enabled${end}"

      for branch in "${missing_upstream_branches[@]}"; do
          printf "%s\n" "${green}Deleting branch:${end}     ${branch}"
          git branch ${delete_flag} "${branch}" -q
          if [[ $? -ne 0 ]]; then
            # If regular delete failed and force is not enabled, check if branch was safely merged
            if [[ ${FORCE_DELETE} != true ]]; then
              if is_branch_safely_merged "${branch}" "${default_branch}"; then
                printf "%s\n" "${blue}Branch appears to be squash/rebase merged, deleting safely${end}"
                git branch -D "${branch}" -q
                if [[ $? -eq 0 ]]; then
                  printf "%s\n" "✅  ${green}Successfully deleted merged branch${end} ${branch}"
                else
                  printf "%s\n" "❌  ${red}Could not delete${end} ${branch}"
                fi
              else
                printf "%s\n" "❌  ${red}Could not delete${end} ${branch}"
                printf "%s\n" "${yellow}Branch has unmerged changes. Try using --force flag if you're sure${end}"
              fi
            else
              printf "%s\n" "❌  ${red}Could not delete${end} ${branch}"
            fi
          fi
      done
    else
        printf "%s\n" "${green}Dry run: not deleting branches${end}"
    fi
fi

# Trying to checkout the home branch, if this branch was deleted, it will silently fail and stay on the default_branch
git checkout $home_branch >/dev/null 2>&1 # hide response

printf "\n%s\n" "${green}Done${end}"
